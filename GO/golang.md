- go语言两种执行流程的区别:
1.先编译生成的可执行文件,可以将该可执行文件拷贝到没有gosdk环境的机器上,仍然可以执行.2.直接通过go run的方式执行文件,也需要go的开发环境,否则go的命令无法执行.3.在编译时,编译器会将程序运行以来的库文件包换在可执行的文件中,所以,可执行文件大了很多.

- 在go中所有的数据类型都有一个默认值,当没有被赋值时，会使用默认值（零值）.

- 基本数据类型的转换必须要显示转换. golang中的数据类型不能自动转换. 跟Python中不相同的时,golang中的算加法的时候也必须强转. 

- 在将string类型转成基本数据类型时,要确保string类型能够转成有效数据.如果string类型转其他类型是,不能成功,则设为默认值.

- golang中获取内存地址的方式: &

- golang中的len()函数获取的是字符串占的对应字节的额长度, 两个中文字, 占对应的6个字节. 要想获得中文字符对对应的中文字符的长度需要使用urf8库的RuneCountInString()函数

- 指针变量指向一个内存地址, 用*取对应的值. 用&取内存地址. 且类型必须匹配.

- golang中的值类型包括int系列, float系列, bool系列, string, 数组和结构体struct. 值类型,都有对应的指针类型.

- 引用类型: 指针,切片,map,管道,interfac

- &&也叫短路与: 如果一个条件为false, 则第二个条件不会判断, 最终结果为false.

- || 也叫短路或: 如果第一个条件为true, 则第二个条件不会判断,最终结果为true.

- 二进制转十进制: 每一位数字乘以2的(n-1)次方之和. 八进制转十进制: 每一位数字乘以8的(n-1)次方. 十六进制转十进制: 每一位数字乘以16的(n-1)次方.




修改文件001


- 十进制转换二进制: 用十进制的数跟2求商, 余数倒序排列.

- 原码, 反码, 补码:1. 二进制的最高位是符号位:0表示正数,1表示负数.  2.正数的原码,反码,补码都一样.3:负数的反码:他的原码符号位不变, 其他位取反(0>>1, 1>>0) 4: 负数的补码=它的反码+1.   5:0的反码, 补码都是0.  6: 在计算机运算时.都是以补码的方式运算的. 其原理参考：https://blog.csdn.net/zl10086111/article/details/80907428


- golang中的3个位运算: 按位与&, 按位或|, 按位异或^ (这些个运算都是通过补码来运算的)
- golang中的移位运算符: 右移运算符 >>: 低位溢出, 符号位不变, 并用符号位补溢出的高位. 左移运算符: <<: 符号位不变, 低位补0.
- golang中遍历字符串时有中文需要注意下标问题,以及用下标取值时,需要将含有中文得字符串用[]rune(string)转换成切片类型(感觉不是很友好), 或者用 range的方式.
- 跨包调用函数, 函数的首字母必须大写. 否则认为是包的私有函数. 且引包的路径默认从src开始.
- 在同一个包下, 不能有相同的函数名.(同一个包, 不是同一个文件, 同一个文件当然也是不可以的)
- 基础类型数据和数组默认都是值传递, 即进行值拷贝. 在函数内修改, 不会影响到原来的值(数组也是值传递有点骚)
- 如果希望函数内的变量能修改函数外的变量(值得是默认以值传递的数据类型),可以传入连梁的地址&, 函数内以指针的方式操作变量.从而达到修改原数据的目的(类似于python中的global)
- 用type可以自定义类型,函数.
- len() 是按字节返回数字, 并非是按字符返回的, ascii的字符占一个字节, 中文占用三个字节.
- defer后面的语句会压入到defer栈中,该栈时先入后出.
- golang中的数组是*值类型*,python中的数组是引用类型. 因此golang中的数组是值传递,而不是引用传递.
- 数组的地址是第一个元组的地址, 每个元素的地址第一个元素的地址+是元素的类型的大小.(内存地址是连续的, 以第一个元素的地址为基本, 每个元素的类型递增.)
- 切片中保存的是三个值: 1. 地址: 切片对应的数组的第一个值得索引. 2. 长度: 切片的长度. 3. 容量: 默认的切片对应数组的从起始位置到数组下标为-1的总长度.
每个切片的大小总是固定的, 都是24个字节, 每个信息都是8个字节(64位的电脑)
- 数组是值类型,通过append()函数操作切片可以修改数组中的值.
- golang声明一个数组之后, 会在内存当中开辟一段固定长度,连续的空间存放数组中的各个元素, 这些元素的数据类型完全相同.
- copy(slice1, slice2) 把数据从slice2的数据拷贝到slice1中, 其中slice1, slice2中的数据必须都是切片类型. 如果slice1中的长度小于slice2的长度.则会从slice2中截取slice1长度的数据. slice1 和slice2的数据空间是独立的, 相互不影响(可以理解为深拷贝).
- 切片的容量的作用: 当通过append()操作切片类型添加值时, 当添加的值的数量没有超过切片的容量时, 其切片指向对应数组的指针不会改变, 也就是说并不会分配新的数组. 当超过时容量值时, 会分配新的数组, 其容量值会加倍(超过1024就是增加25%).  这里需要注意的是: 切片append的值超过容量时, 会指向新的数组, 会与原来的数组分离. 
- **数组的固定长度**: 数组不可增长,不可缩减. 想要拓展数组, 只能创建新的数组,将原数组的元素复制到新数组. **连续空间**: 可以在缓存中保留的时间工程, 搜索速度更快, 是一种非常高效的数据结构,同时可以通过数值下标的方式访问数组中的某个元素.
**数据类型**: 数组中所有元素的数据类型必须相同,限制了每个块中可以存放什么样的数据, 以及每个块可以存放多少字节的数据. **数组默认值**:数组创建后,如果没有赋值,默认为零值(例如:数值类型数组,默认值为0, 字符串数组,默认值为"",bool数组:默认值为false.)
- 使用数组的步骤: 1.声明数组并开辟连续空间. 2.给数组各个元素赋值. 3.使用数组
- go的数组属于*值类型*,在默认的情况下是值传递,因此会进行值拷贝且数组间不会受影响. 如果在函数中修改原来的数组,可以使用引用传递的方式修改(通过指针修改)
- string底层是一个byte数组,所以string也可以进行切片处理.
- 字符串通过*+*拼接其他的字符串, 其地址并不会改变.
- 双引号: 用来创建*可解析的字符串字面量*(支持转移, 但不能用来引用多行); 反引号: 用来创建*原生的字符串字面量*, 这些字符串可能有多行组成 ; 单引号: 一般用来表示 rune类型, 即:码点字面量. 
- 对string字符串进行修改的话, 可以将其转换成切片类型[]byte(不兼容中文)和[]rune(兼容中文),通过切片的方式进行修改,然后再将切片转换成字符串. (其实可以理解为数组的修改, 数组可以通过切片进行修改)
- map数据类型(键值对),在使用的时候需要用make进行分配内存. map类型的切片, 需要进行make两次: 第一次:make是为切片分配内存. 第二次是为map数据类型分配内存. 
- map的遍历必须使用for-range结构,这里不要用下标取值(跟python中的dict数据类型相似.)
- 切片的增加需要使用append方法.
- map数据类型是无序存储的, 如果有需求则需要手动排序.
- map是引用类型, 遵循引用类型传递的机制, 在一个函数中接收了map参数, 会修改原来的map.
- map的是可以自动扩容的(即:是可变类型). 数组是不可以超过其大小的, 但是值是可以改变的.
- 目前已知的切片类型：
- Golang并不是春最的面向对象语言。 Golang支持面向对象编程特性。
- Golang没有类(class), Go语言的结构体(struct)和其他编程语言的类(class)有同等地位，可以理解为Golang是基于struct来实现OOP特性的。
- 封装、继承、多态。 
- 结构体类型是值类型，在函数/方法的调用中，遵守值类型的传递机制，是值拷贝传递方式。
- 如果在方法中修改结构体变量的值，需要通过结构体指针的方式来处理。
- Golang中方法作用在指定的数据类型上(即：和指定的数据类型绑定)，因此 自定义类型都可以有方法。而不仅仅是struct,比如int，float32等都可以在自定义类型的基础上有自己的方法。
- 方法的访问范围控制的规则，和函数一样。即：方法名首字母小写，只能在本包访问，方法首字母大写，可以在本包以及以外的包访问。
- 函数和方法的区别: 函数不需要和特定的类型绑定. 方法需要和指定的类型绑定. 
- 

