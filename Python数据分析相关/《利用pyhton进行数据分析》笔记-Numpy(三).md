### 1.将条件逻辑表述维数组运算(np.where)
        
      # 简单的例子
      temp_array = np.array([1,2,3,4,5,6])
    #将temp_array中大于三的数全部重置为6
     # 1.版本
     for i,j in enumerate(temp_array):
        if j > 3:
            temp_array[i] = 6
        
    temp_array #  返回值 array([1, 2, 3, 6, 6, 6])

    # map+lambda版本
    temp_array = np.array([1,2,3,4,5,6])
    np.array(list(map(lambda i:6 if i > 3 else i,temp_array))) # 返回值：array([1, 2, 3, 6, 6, 6])


     # np.where版本
    temp_array = np.array([1,2,3,4,5,6])
    np.where(temp_array > 3, 6, temp_array) # array([1, 2, 3, 6, 6, 6])

前两种的方式如果处理的是大数组的处理速度并不是很快，而且如果是多维数组的，处理起来也是捉襟见肘。那么，  `np.where`显然是为此而生。来看一下参数 `where(condition, x=None, y=None)`,其中的`condition`为判断条件，如果判断条件为True， 则为x，否则为y。x,y 可以是标量， 通常，`np.where`返回的是满足条件的新的数组。如果只给定条件  `condition`， 则返回满足条件的元组。

    #只传一个condition
    x = np.arange(12).reshape(3, 4)
    x

    # array([[ 0,  1,  2,  3],
    #        [ 4,  5,  6,  7],
    #        [ 8,  9, 10, 11]])

    np.where( x > 5 ) # 返回值的type：tuple。需要注意的是返回的并不是数组， 而是一个元祖，里边分别是满足条件的每个维度的下标
    # (array([1, 1, 2, 2, 2, 2], dtype=int64),
    #  array([2, 3, 0, 1, 2, 3], dtype=int64))

    x[np.where( x > 3.0 )]  # 返回数组的方式
    #array([ 4,  5,  6,  7,  8,  9, 10, 11])

来看一下， 更为复杂的嵌套格式：

     a = np.array([1,2,3,8,5,6,9])
    b = np.array([2,3,4,5,6,8,9])

    c = []
    for i in range(7):
        if a[i] == b[i]:
            c.append(-1)
        elif b[i] > a[i]:
            c.append(-66)
        else:
            c.append(0)

    c # [-66, -66, -66, 0, -66, -66, -1]


    
    a = np.array([1,2,3,8,5,6,9])
    b = np.array([2,3,4,5,6,8,9])

    np.where(a==b, -1, np.where(b>a, -66,0))# array([-66, -66, -66,   0, -66, -66,  -1])



 
### 2.数学和统计方法
可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。一般的运算都是聚合计算(即一组数经过计算得到一个数)，而其他如`cumsum`(所有元素的累计和)、`cunprod`(所有元素的累计积)之类的方法则不聚合， 产生的新数组是由中间的结果组成的。

     temp_array = np.arange(20).reshape(4,5)
    temp_array
    # array([[ 0,  1,  2,  3,  4],
    #        [ 5,  6,  7,  8,  9],
    #        [10, 11, 12, 13, 14],
    #        [15, 16, 17, 18, 19]])

    #求平均值
    temp_array.mean() # 等价与np.mean(temp_array)
    # 返回值：9.5
    # 按轴进行求平均值
    temp_array.mean(axis=0) # 按0轴进行求平均值
    # 返回值：array([ 7.5,  8.5,  9.5, 10.5, 11.5])
    temp_array.mean(axis=1) #按1轴进行求平均值
    # 返回值：array([ 2.,  7., 12., 17.])

    # 进行求和
    temp_array.sum()# 等价于 np.sum(temp_array)
    # 返回值：190

    # 按轴进行求和
    temp_array.sum(axis=1) # 按1轴进行求和
    # 返回值：array([10, 35, 60, 85])

    temp_array.sum(axis=0)# 按0轴进行求和
    # 返回值：array([30, 34, 38, 42, 46])

    # 累计和：
     temp_array.cumsum(0)
     # 返回值：array([[ 0,  1,  2,  3,  4],
    #        [ 5,  7,  9, 11, 13],
    #        [15, 18, 21, 24, 27],
    #        [30, 34, 38, 42, 46]], dtype=int32)

    temp_array.cumsum(1)    
    # 返回值：array([[ 0,  1,  3,  6, 10],
    #        [ 5, 11, 18, 26, 35],
    #        [10, 21, 33, 46, 60],
    #        [15, 31, 48, 66, 85]], dtype=int32)

    temp_array.cumprod(0)
    #返回值：
    # array([[   0,    1,    2,    3,    4],
    #        [   0,    6,   14,   24,   36],
    #        [   0,   66,  168,  312,  504],
    #        [   0, 1056, 2856, 5616, 9576]], dtype=int32)

    temp_array.cumprod(1)
    # # 返回值：
    # array([[      0,       0,       0,       0,       0],
    #        [      5,      30,     210,    1680,   15120],
    #        [     10,     110,    1320,   17160,  240240],
    #        [     15,     240,    4080,   73440, 1395360]], dtype=int32)
    

    
###### 2.1用于布尔型数组的方法：
在数学和统计方法中，布尔值会被强制转换为0和1。所以， sum经常用来对数组中的True的个数进行计算。另外还有两种方法：   `any` 用于测试数组中是否存在True，如果是返回True，否则返回Flase。 `all`用来判断数组中的元素是否全为True，如果是返回True，否则返回Flase。。这两种方法同样适用于非布尔型数组，即所有非0元素都会当作True。

    temp_array = np.arange(10)
    (temp_array>5).sum()  # 统计数组中，满足条件的元素的个数。

    
    (temp_array>5).all()# 返回指：False

    (temp_array>5).any()# 返回值：True

### 3.排序
    
    temp_array =np.random.randn(8)
    temp_array #array([ 1.63138405,  0.02460054,  0.79967461, -0.56063733, -0.52650574, 0.10417684, -1.63061352, -0.15933881])
    temp_array.sort() # 这里直接修改的源数据，即temp_array
    temp_array #array([-1.63061352, -0.56063733, -0.52650574, -0.15933881,  0.02460054, 0.10417684,  0.79967461,  1.63138405])

    # 多维数组可以传入轴的编号，按轴进行排序，直接修改的是源数据
    temp_array = np.random.randn(5,3)
    temp_array
     #返回值：array([[-0.44019667,  0.66656445,  0.01409205],
           [-0.05383199, -1.77110565, -2.14482723],
           [-0.08729912, -0.2606773 , -0.8455391 ],
           [-0.37604029,  0.43741626,  0.70823732],
           [-1.25897325, -1.16871423, -0.40298885]])

    temp_array.sort(0)# 按0号轴进行排序
    temp_array
    #返回值： array([[-1.25897325, -1.77110565, -2.14482723],
       [-0.44019667, -1.16871423, -0.8455391 ],
       [-0.37604029, -0.2606773 , -0.40298885],
       [-0.08729912,  0.43741626,  0.01409205],
       [-0.05383199,  0.66656445,  0.70823732]])
    temp_array.sort(1) # 按1号轴进行排序
     temp_array
    #返回值： array([[-2.14482723, -1.77110565, -1.25897325],
       [-1.16871423, -0.8455391 , -0.44019667],
       [-0.40298885, -0.37604029, -0.2606773 ],
       [-0.08729912,  0.01409205,  0.43741626],
       [-0.05383199,  0.66656445,  0.70823732]])

    # np.sort
    temp_array = np.random.randn(10)
    temp_array
     #返回值：array([-0.69450073, -0.9602936 , -0.78519972,  0.16057989,  0.82380485,
       2.41590235,  1.42378936,  2.07849092,  0.73592523, -0.6379529 ])
    
    np.sort(temp_array) # 有返回值，返回值是排序完的副本， 而不是视图
       # 返回值：array([-0.9602936 , -0.78519972, -0.69450073, -0.6379529 ,  0.16057989,
        0.73592523,  0.82380485,  1.42378936,  2.07849092,  2.41590235])


######3.1 唯一化(去重)以及其他的集合逻辑

    temp_array = np.array([1,3,2,4,5,5,6,5,3,2,4,11,10,11,2,3,4,3])
    np.unique(temp_array) # 返回值：array([ 1,  2,  3,  4,  5,  6, 10, 11])
    
    temp_list = [1,3,2,4,5,5,6,5,3,2,4,11,10,11,2,3,4,3]
    sorted(set(temp_list)) # 返回值： [1, 2, 3, 4, 5, 6, 10, 11]
    


### 4.文件的读写
  `np.save` 和 `np.load`是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在拓展名为.npy的文件中。使用`np.savez`可以将多个数组保存到一个压缩文件中，将数组以关键字参数传入即可。读取的时候， 依然用`np.load`， 但得到的是一个类似字典的对象，需要通过参数进行取数组。读取csv文件的， 我实际用的都是pandas的， 这里不过多的展开了。


    temp_array = np.arange(15)
    np.save('test', temp_array) # 生成test.npy的文件  自动添加上的。
    temp_array2 = np.load('test.npy')
    temp_array2
    # 返回值：array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])

    # np.savez的用法，可保存压缩文件
    np.savez('test2', a=temp_array, b=temp_array3) #  生成test.npz的压缩文件，参数名字不定，可以随意取。
    test2 = np.load('test2.npz')
    test2 # 返回值 ：<numpy.lib.npyio.NpzFile at 0x1135a14a8>
    test2.files # 返回其中的键(或者文件名)  返回值：['a', 'b']
    test2['a']
    #返回值：array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
    test2['b']
    #返回值：array([[0, 1, 2, 3, 4],
    #        [5, 6, 7, 8, 9]])

### 5.线性代数 
两个数组相乘，得到的是元素级的乘积， 而无法得到矩阵点积。所以一下的方法就是操作数组如矩阵。
矩阵的基本运算法则还是挺重要的，后期的机器学习，也需要用的到。需要重点看一下矩阵运算的法则，这里不过多的展开了，用的到， 相信我！

    # 矩阵点积：
    #两种形状 (2,3)*(3*2) 得到的形状应该是(2,2)

    a = np.arange(6).reshape(2,3)
    #返回值： array([[0, 1, 2],
    #        [3, 4, 5]])
    b = np.arange(6).reshape(3,2)
    # 返回值 ：array([[0, 1],
    #        [2, 3],
    #        [4, 5]])
    np.dot(a,b) # 返回值的形状是(2,2)
    #array([[10, 13],
    #        [28, 40]])



# `总注：有关Numpy的笔记差不多就到这里了，通过这本书， 可以感受的到，作者的重点不是这里，而是pandas。我也是感觉比较重要的地方简单的做了笔记，请读者老爷多多指教。另外书上最后的例子给的是随机漫步，我不打算用这个例子。下一个笔记，我将用一个我自己处理过的简单的验证码用来Numpy笔记的终章。`



####  *本人水平有限， 如有错误欢迎提出指正！如有参考， 请注明出处！！原创不易，禁止抄袭，遇抄必肛！！！*



